<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&family=Roboto:wght@300;400;700&display=swap');

        :root {
            /* Warm Tones Palette */
            --dark-bg: #1C1C1C; /* soft black */
            --light-text: #F5E8D8; /* warm beige */
            --primary-accent: #DAA520; /* golden yellow */
            --secondary-accent: #FF6F61; /* muted coral */
            --hover-accent: #FF4500; /* burnt orange */

            /* Derived/borrowed colors for UI elements */
            --dark-panel-bg: #2C2C2C; /* slate gray */
            --dark-border: #444444; /* dark gray */

            /* Log-specific colors */
            --log-location: var(--secondary-accent);
            --log-goal: var(--primary-accent);
            --log-reputation: var(--primary-accent);
            --log-inventory: var(--light-text);
            --log-error: var(--hover-accent);
            --log-warning: var(--secondary-accent);
        }

        body {
            background-color: var(--dark-bg);
            color: var(--light-text);
            font-family: 'Roboto', sans-serif;
        }

        h1, h2, h3, h4, h5, h6, .card-header, .accordion-button {
            font-family: 'IM Fell English', serif;
        }

        .card, .accordion-item {
            background-color: var(--dark-panel-bg);
            border: 1px solid var(--dark-border);
        }

        .card-header, .accordion-header {
            border-bottom: 1px solid var(--dark-border);
        }

        .accordion-button {
            background-color: var(--dark-panel-bg);
            color: var(--light-text);
        }
        .accordion-button:not(.collapsed) {
            background-color: var(--dark-bg);
            color: var(--primary-accent);
        }
        .accordion-button:focus {
            box-shadow: 0 0 0 0.25rem rgba(218, 165, 32, 0.25);
        }
        .accordion-button::after {
            filter: invert(1) grayscale(100%) brightness(200%);
        }

        /* Ensure the side panels container doesn't overflow the page */
        .side-panels-container {
            max-height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #log-panel {
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .log-location { color: var(--log-location); }
        .log-goal { color: var(--log-goal); }
        .log-reputation { color: var(--log-reputation); }
        .log-inventory { color: var(--log-inventory); }
        .log-error { color: var(--log-error); font-weight: bold; }
        .log-warning { color: var(--log-warning); }
        .log-game-event { font-style: italic; color: var(--primary-accent); }

        /* Responsive Layout */
        @media (max-width: 767.98px) {
            main {
                flex-direction: column;
            }
            .main-content-col {
                order: 1; /* Log panel first */
                height: 50vh; /* Allocate more space */
            }
            .side-panels-col {
                order: 2; /* Side panels second */
                height: 50vh;
            }
            #side-panels-container {
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                width: 100%;
            }
            .accordion {
                display: flex;
                flex-direction: row;
            }
            .accordion-item {
                width: 300px;
                flex-shrink: 0;
            }
        }
    </style>
</head>
<body>
    <main class="container-fluid d-flex flex-column p-3">
        <div class="row flex-grow-1">
            <!-- Main Content: Event Log -->
            <div class="col-md-5 d-flex flex-column main-content-col">
                <div class="card h-100">
                    <div class="card-header">
                        <h4>Log</h4>
                    </div>
                    <div id="log-panel" class="card-body overflow-auto">
                        <!-- Game events will be logged here -->
                    </div>
                </div>
            </div>

            <!-- Side Panels Col 1 -->
            <div class="col-md-4 d-flex flex-column side-panels-col">
                <div id="side-panels-container" class="side-panels-container">
                    <div class="accordion" id="side-panels">
                        <!-- Player Panel -->
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                            <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#player-panel-collapse" aria-expanded="true" aria-controls="player-panel-collapse">
                                Player
                            </button>
                        </h2>
                        <div id="player-panel-collapse" class="accordion-collapse collapse show">
                            <div id="player-panel" class="accordion-body">
                                <!-- Player stats and reputation go here -->
                            </div>
                        </div>
                    </div>
                    <!-- Exits Panel -->
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exits-panel-collapse" aria-expanded="false" aria-controls="exits-panel-collapse">
                                Exits
                            </button>
                        </h2>
                        <div id="exits-panel-collapse" class="accordion-collapse collapse">
                            <div id="exits-panel" class="accordion-body">
                                <!-- Clickable exits go here -->
                            </div>
                        </div>
                    </div>
                    <!-- Interactibles Panel -->
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#interact-panel-collapse" aria-expanded="false" aria-controls="interact-panel-collapse">
                                Interact
                            </button>
                        </h2>
                        <div id="interact-panel-collapse" class="accordion-collapse collapse">
                            <div id="interact-panel" class="accordion-body">
                                <!-- Characters and items to interact with -->
                            </div>
                        </div>
                    </div>
                    <!-- Inventory Panel -->
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#inventory-panel-collapse" aria-expanded="false" aria-controls="inventory-panel-collapse">
                                Inventory
                            </button>
                        </h2>
                        <div id="inventory-panel-collapse" class="accordion-collapse collapse">
                            <div id="inventory-panel" class="accordion-body">
                                <!-- Player inventory -->
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>
            <!-- Side Panels Col 2 -->
            <div class="col-md-3 d-flex flex-column side-panels-col">
                 <div id="side-panels-container-2" class="side-panels-container">
                    <div class="accordion" id="side-panels-2">
                    <!-- Goals Panel -->
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#goals-panel-collapse" aria-expanded="false" aria-controls="goals-panel-collapse">
                                Goals
                            </button>
                        </h2>
                        <div id="goals-panel-collapse" class="accordion-collapse collapse">
                            <div id="goals-panel" class="accordion-body">
                                <!-- Active and completed goals -->
                            </div>
                        </div>
                    </div>
                    <!-- Map Panel (disabled)
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#map-panel-collapse" aria-expanded="false" aria-controls="map-panel-collapse">
                                Map
                            </button>
                        </h2>
                        <div id="map-panel-collapse" class="accordion-collapse collapse">
                            <div id="map-panel" class="accordion-body">
                                <!-- Location map will be rendered here -->
                            </div>
                        </div>
                    </div>
                    -->
                    <!-- Factions Panel -->
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#factions-panel-collapse" aria-expanded="false" aria-controls="factions-panel-collapse">
                                Factions
                            </button>
                        </h2>
                        <div id="factions-panel-collapse" class="accordion-collapse collapse">
                            <div id="factions-panel" class="accordion-body">
                                <!-- Faction standings -->
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: false });
    </script>
    <script src="web/game-data.js"></script>
    <script>
        console.log("Game script loaded.");
        class DialogueManager {
            constructor(game) {
                this.game = game;
                this.active = false;
                this.character = null;
                this.currentNodeKey = null;
                this.dialogueHistory = [];
            }
        }
        class Character {
            constructor(name, attributes, faction, inventory, skills = {}, equipment = { mainHand: null, offHand: null, armor: null }, dialogue = {}, interactions = {}) {
                this.name = name;
                this.attributes = attributes; // e.g., { strength: 80, wit: 60 }
                this.faction = faction;
                this.inventory = inventory; // Array of item keys
                this.skills = skills; // e.g., { 'heavy-weapons': 20, 'trading': 15 }
                this.equipment = equipment; // e.g., { mainHand: 'sword', armor: 'chainmail' }
                this.dialogue = dialogue;
                this.interactions = interactions;
            }

            start(charKey) {
                this.character = this.game.characters[charKey];
                if (!this.character || !this.character.dialogue || !this.character.dialogue.nodes) {
                    // Fallback to old system or a simple message if new structure is not present
                    this.game.interactWithCharacter_old(charKey);
                    return;
                }

                this.active = true;
                this.dialogueHistory = [];

                const dialogue = this.character.dialogue;
                let startNodeKey = dialogue.start_node || 'default';

                // Check flags for a more specific starting point, mimicking the old logic
                const reversedFlags = [...this.game.flags].reverse();
                for (const flag of reversedFlags) {
                    if (dialogue.nodes[flag]) {
                        startNodeKey = flag;
                        break;
                    }
                }

                this.navigateTo(startNodeKey);
            }

            navigateTo(nodeKey) {
                this.currentNodeKey = nodeKey;
                const node = this.character.dialogue.nodes[this.currentNodeKey];

                if (!node) {
                    console.error(`Dialogue node "${nodeKey}" not found for character "${this.character.name}".`);
                    this.end();
                    return;
                }

                this.dialogueHistory.push(nodeKey);

                // Execute any actions on this node
                if (node.actions) {
                    node.actions.forEach(action => this.game.executeDialogueAction(action));
                }

                this.render();

                if (node.ends_dialogue) {
                    this.end();
                } else if (node.leads_to) {
                    this.navigateTo(node.leads_to);
                }
            }

            render() {
                if (!this.active) return;

                const node = this.character.dialogue.nodes[this.currentNodeKey];
                let message = `<p><strong>${this.character.name}:</strong> "${node.text}"</p>`;

                if (node.choices && node.choices.length > 0) {
                    message += '<div class="dialogue-choices">';
                    node.choices.forEach((choice, index) => {
                        if (this.game.checkConditions(choice.condition)) {
                             message += `<button class="btn btn-sm btn-outline-primary mt-1" onclick="game.dialogueManager.choose(${index})">${choice.text}</button>`;
                        }
                    });
                    message += '</div>';
                }

                this.game.logMessage(message, 'dialogue');
            }

            choose(choiceIndex) {
                if (!this.active) return;

                const node = this.character.dialogue.nodes[this.currentNodeKey];
                const choice = node.choices[choiceIndex];

                if (choice.leads_to) {
                    this.navigateTo(choice.leads_to);
                } else {
                    this.end();
                }
            }

            end() {
                if(this.active) {
                    this.game.logMessage("The conversation ends.", "game-event");
                    this.active = false;
                    this.character = null;
                    this.currentNodeKey = null;
                    this.dialogueHistory = [];
                    this.game.updateUI(); // Update UI in case the conversation changed something
                }
            }
        }

        class Game {
            constructor() {
                // Game Data
                this.locations = {};
                this.characters = {};
                this.items = {};
                this.goals = {};

                // Game State
                this.player = null;
                this.currentLocation = null;
                this.visitedLocations = new Set();
                this.gameTime = 0; // in-game days
                this.reputation = {}; // e.g., { 'Danes': 50, 'Geats': 70 }
                this.flags = new Set(); // For story progression

                // UI Element References
                this.ui = {
                    logPanel: document.getElementById('log-panel'),
                    playerPanel: document.getElementById('player-panel'),
                    exitsPanel: document.getElementById('exits-panel'),
                    actionPanel: document.getElementById('interact-panel'), // Renamed for clarity
                    inventoryPanel: document.getElementById('inventory-panel'),
                    goalsPanel: document.getElementById('goals-panel'),
                    // mapPanel: document.getElementById('map-panel'),
                    factionsPanel: document.getElementById('factions-panel'), // New panel
                };

                this.dialogueManager = new DialogueManager(this);
            }

            executeDialogueAction(action) {
                if (!action) return;

                if (action.add_flag) {
                    this.flags.add(action.add_flag);
                    this.logMessage(`(Flag added: ${action.add_flag})`, 'game-event');
                }
                if (action.remove_flag) {
                    this.flags.delete(action.remove_flag);
                    this.logMessage(`(Flag removed: ${action.remove_flag})`, 'game-event');
                }
                if (action.add_item) {
                    this.player.inventory.push(action.add_item);
                     this.logMessage(`You received ${this.items[action.add_item].name}.`, 'inventory');
                }
                if (action.remove_item) {
                    this.player.inventory = this.player.inventory.filter(key => key !== action.remove_item);
                    this.logMessage(`You lost ${this.items[action.remove_item].name}.`, 'inventory');
                }
                if (action.change_reputation) {
                    this.changeReputation(action.change_reputation.faction, action.change_reputation.amount);
                }
                if (action.complete_goal) {
                    this.completeGoal(action.complete_goal);
                }
            }

            checkConditions(condition) {
                if (!condition) return true;

                if (condition.has_flag && !this.flags.has(condition.has_flag)) return false;
                if (condition.missing_flag && this.flags.has(condition.missing_flag)) return false;

                if (condition.has_item) {
                    if (!this.player.inventory.includes(condition.has_item)) return false;
                }
                if (condition.reputation_greater_than) {
                    const rep = this.reputation[condition.reputation_greater_than.faction] || 0;
                    if (rep <= condition.reputation_greater_than.amount) return false;
                }
                if (condition.reputation_less_than) {
                    const rep = this.reputation[condition.reputation_less_than.faction] || 0;
                    if (rep >= condition.reputation_less_than.amount) return false;
                }

                return true;
            }

            logMessage(message, type = 'normal') {
                const logEntry = document.createElement('p');
                logEntry.innerHTML = message; // Use innerHTML to allow for simple formatting
                logEntry.className = `log-entry log-${type}`;
                this.ui.logPanel.appendChild(logEntry);
                this.ui.logPanel.scrollTop = this.ui.logPanel.scrollHeight; // Auto-scroll to bottom
            }

            calculateSuccessChance(skillName, baseChance = 50) {
                const skillValue = this.player.skills[skillName] || 0;
                // Formula: base chance + ( (100 - base chance) * (skill / 100) )
                // A skill of 50 increases a 50% chance to 75%
                const successRate = baseChance + ((100 - baseChance) * (skillValue / 100));
                return Math.min(successRate, 100); // Cap at 100%
            }

            changeReputation(faction, amount) {
                if (this.reputation[faction]) {
                    this.reputation[faction] = Math.max(0, this.reputation[faction] + amount);
                    this.logMessage(`Your reputation with ${faction} has changed by ${amount}.`, 'reputation');
                }
                this.updateUI();
            }

            equipItem(itemKey) {
                const item = this.items[itemKey];
                if (!item || !item.slot) return;

                // Unequip any item in the same slot
                if (this.player.equipment[item.slot]) {
                    this.unequipItem(item.slot);
                }

                // Move item from inventory to equipment
                this.player.inventory = this.player.inventory.filter(key => key !== itemKey);
                this.player.equipment[item.slot] = itemKey;
                this.logMessage(`You equip the ${item.name}.`, 'inventory');
                this.updateUI();
            }

            unequipItem(slot) {
                const itemKey = this.player.equipment[slot];
                if (!itemKey) return;
                const item = this.items[itemKey];

                // Move item from equipment to inventory
                this.player.equipment[slot] = null;
                this.player.inventory.push(itemKey);
                this.logMessage(`You unequip the ${item.name}.`, 'inventory');
                this.updateUI();
            }

            takeItem(itemKey) {
                const item = this.items[itemKey];
                if (!item) return;

                // Remove from location and add to player inventory
                this.currentLocation.items = this.currentLocation.items.filter(key => key !== itemKey);
                this.player.inventory.push(itemKey);

                this.logMessage(`You take the ${item.name}.`, 'inventory');
                this.updateUI();
                this.saveState();
            }

            interactWithCharacter(charKey) {
                if (this.dialogueManager.active) {
                    this.logMessage("You are already in a conversation.", "warning");
                    return;
                }
                this.dialogueManager.start(charKey);
            }

            interactWithCharacter_old(charKey) {
                const character = this.characters[charKey];
                if (!character) return;

                let message = `<p>You exchange pleasantries with ${character.name}.</p>`; // Default fallback

                if (character.dialogue) {
                    const reversedFlags = [...this.flags].reverse();
                    let foundMessage = false;

                    for (const flag of reversedFlags) {
                        if (character.dialogue[flag]) {
                            message = `<p><strong>${character.name}:</strong> "${character.dialogue[flag]}"</p>`;
                            foundMessage = true;
                            break;
                        }
                    }

                    if (!foundMessage && character.dialogue.default) {
                        message = `<p><strong>${character.name}:</strong> "${character.dialogue.default}"</p>`;
                    }
                }

                // Check for special "give item" interactions
                if (character.interactions && character.interactions.gives) {
                    for (const itemKey in character.interactions.gives) {
                        if (this.player.inventory.includes(itemKey)) {
                            const item = this.items[itemKey];
                            message += `<button class="btn btn-sm btn-info mt-1" onclick="game.giveItem('${itemKey}', '${charKey}')">Offer ${item.name}</button>`;
                        }
                    }
                }

                this.logMessage(message, 'dialogue');
            }

            giveItem(itemKey, charKey) {
                const character = this.characters[charKey];
                const item = this.items[itemKey];

                if (!this.player.inventory.includes(itemKey) || !character || !item) {
                    this.logMessage('You cannot do that.', 'warning');
                    return;
                }

                const interaction = character.interactions?.gives?.[itemKey];

                if (interaction) {
                    if (interaction.response) {
                        this.logMessage(`<p><strong>${character.name}:</strong> "${interaction.response}"</p>`, 'dialogue');
                    }

                    if (interaction.removes_item) {
                        this.player.inventory = this.player.inventory.filter(key => key !== itemKey);
                    }

                    if (interaction.adds_flag) {
                        this.flags.add(interaction.adds_flag);
                    }

                    if (interaction.rewards) {
                        if (interaction.rewards.items) {
                            interaction.rewards.items.forEach(rewardItemKey => {
                                if (character.inventory.includes(rewardItemKey)) {
                                    character.inventory = character.inventory.filter(key => key !== rewardItemKey);
                                }
                                this.player.inventory.push(rewardItemKey);
                                this.logMessage(`You received the ${this.items[rewardItemKey].name}.`, 'inventory');
                            });
                        }
                        if (interaction.rewards.reputation) {
                            for (const faction in interaction.rewards.reputation) {
                                this.changeReputation(faction, interaction.rewards.reputation[faction]);
                            }
                        }
                    }

                    if (interaction.completes_goal) {
                        const goal = this.goals[interaction.completes_goal];
                        if (goal && (goal.status === 'active' || goal.status === 'locked')) {
                            goal.status = 'completed';
                            this.flags.add(interaction.completes_goal);
                            this.logMessage(`Goal completed: ${goal.title}`, 'goal');
                        }
                    }
                } else {
                    this.logMessage(`${character.name} has no interest in the ${item.name}.`);
                }

                this.updateUI();
                this.saveState();
            }

            _getSafeMermaidId(name) {
                // Mermaid IDs can't have special characters or spaces.
                // Replace spaces and any non-alphanumeric characters with underscores.
                return name.replace(/[^a-zA-Z0-9_]/g, '_');
            }

            areGoalConditionsMet(goal) {
                if (!goal.conditions) {
                    return true; // No conditions means it's always met
                }

                const { requiredItems, requiredCharacters, requiredFlags, requiredLocation } = goal.conditions;

                // Check location
                if (requiredLocation && this.currentLocation.name !== requiredLocation) {
                    return false;
                }

                // Check items
                if (requiredItems && !requiredItems.every(itemKey => this.player.inventory.includes(itemKey))) {
                    return false;
                }

                // Check characters
                if (requiredCharacters && !requiredCharacters.every(charKey => this.currentLocation.characters.includes(charKey))) {
                    return false;
                }

                // Check flags
                if (requiredFlags && !requiredFlags.every(flag => this.flags.has(flag))) {
                    return false;
                }

                return true;
            }

            getGoalRequirementText(goal) {
                if (!goal.conditions) return '';

                const requirements = [];
                const { requiredItems, requiredCharacters, requiredFlags, requiredLocation } = goal.conditions;

                if (requiredLocation && this.currentLocation.name !== requiredLocation) {
                    // Find the location key from its name for display
                    const locKey = Object.keys(this.locations).find(key => this.locations[key].name === requiredLocation);
                    requirements.push(`Be at ${this.locations[locKey]?.name || requiredLocation}`);
                }

                if (requiredItems) {
                    requiredItems.forEach(itemKey => {
                        if (!this.player.inventory.includes(itemKey)) {
                            requirements.push(`Have '${this.items[itemKey]?.name || itemKey}'`);
                        }
                    });
                }

                if (requiredCharacters) {
                    requiredCharacters.forEach(charKey => {
                        if (!this.currentLocation.characters.includes(charKey)) {
                            requirements.push(`Be with ${this.characters[charKey]?.name || charKey}`);
                        }
                    });
                }

                if (requiredFlags) {
                    requiredFlags.forEach(flag => {
                        if (!this.flags.has(flag)) {
                            requirements.push(`Complete '${this.goals[flag]?.title || flag}'`);
                        }
                    });
                }

                if (requirements.length === 0) return '';

                return `Requires: ${requirements.join(', ')}`;
            }

            async renderMap() {
                this.ui.mapPanel.innerHTML = ''; // Clear previous map

                // Hardcoded simple graph for debugging
                const mapDefinition = `
graph TD
    A[Start] --> B(End)
`;

                const mermaidContainer = document.createElement('div');
                mermaidContainer.className = 'mermaid';
                mermaidContainer.textContent = mapDefinition;
                this.ui.mapPanel.appendChild(mermaidContainer);

                try {
                    await mermaid.run({ nodes: [mermaidContainer] });
                } catch (e) {
                    console.error("Mermaid rendering error:", e);
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'alert alert-danger';
                    errorDiv.textContent = 'Error rendering map. Test 2';
                    this.ui.mapPanel.appendChild(errorDiv);
                }
            }

            updateUI() {
                // Clear all panels except the log
                Object.entries(this.ui).forEach(([name, panel]) => {
                    if (panel && name !== 'logPanel') {
                        panel.innerHTML = '';
                    }
                });

                // Render Player Panel
                this.ui.playerPanel.innerHTML = `
                    <h5>${this.player.name}</h5>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        ${Object.entries(this.player.attributes).map(([key, value]) => `<li>${key}: ${value}</li>`).join('')}
                    </ul>
                    <p><strong>Skills:</strong></p>
                    <ul>
                        ${Object.entries(this.player.skills).map(([key, value]) => `<li>${key}: ${value}%</li>`).join('')}
                    </ul>
                `;

                // Render Factions Panel
                this.ui.factionsPanel.innerHTML = `
                    <ul>
                        ${Object.entries(this.reputation).map(([key, value]) => `<li>${key}: ${value}</li>`).join('')}
                    </ul>
                `;

                // Render Exits Panel
                const exits = this.currentLocation.connections;
                for (const direction in exits) {
                    const locationName = exits[direction];
                    const button = document.createElement('button');
                    button.className = 'btn btn-outline-primary w-100 mb-2';
                    button.textContent = `${direction.charAt(0).toUpperCase() + direction.slice(1)}: ${locationName}`;
                    button.onclick = () => this.moveTo(locationName);
                    this.ui.exitsPanel.appendChild(button);
                }

                // Render Action Panel
                this.currentLocation.characters.forEach(charKey => {
                    const character = this.characters[charKey];
                    if (character !== this.player) {
                        const button = document.createElement('button');
                        button.className = 'btn btn-outline-secondary w-100 mb-2';
                        button.textContent = `Talk to ${character.name}`;
                        button.onclick = () => this.interactWithCharacter(charKey);
                        this.ui.actionPanel.appendChild(button);
                    }
                });
                this.currentLocation.items.forEach(itemKey => {
                    const item = this.items[itemKey];
                    const button = document.createElement('button');
                    button.className = 'btn btn-outline-success w-100 mb-2';
                    button.textContent = `Take ${item.name}`;
                    button.onclick = () => this.takeItem(itemKey);
                    this.ui.actionPanel.appendChild(button);
                });
                if (this.ui.actionPanel.innerHTML === '') {
                    this.ui.actionPanel.innerHTML = '<p class="text-muted">Nothing to interact with.</p>';
                }

                // Render Inventory Panel
                this.ui.inventoryPanel.innerHTML = '<h6>Equipped</h6>';
                let equippedItems = false;
                for(const slot in this.player.equipment) {
                    const itemKey = this.player.equipment[slot];
                    if(itemKey) {
                        const item = this.items[itemKey];
                        this.ui.inventoryPanel.innerHTML += `<p>${item.name} (${slot}) <button class="btn btn-sm btn-secondary" onclick="game.unequipItem('${slot}')">Unequip</button></p>`;
                        equippedItems = true;
                    }
                }
                if(!equippedItems) this.ui.inventoryPanel.innerHTML += '<p class="text-muted">Nothing equipped.</p>';

                this.ui.inventoryPanel.innerHTML += '<h6 class="mt-3">Carried</h6>';
                if (this.player.inventory.length > 0) {
                    this.player.inventory.forEach(itemKey => {
                        const item = this.items[itemKey];
                        const equipButton = item.slot ? `<button class="btn btn-sm btn-primary" onclick="game.equipItem('${itemKey}')">Equip</button>` : '';
                        this.ui.inventoryPanel.innerHTML += `<p>${item.name} ${equipButton}</p>`;
                    });
                } else {
                    this.ui.inventoryPanel.innerHTML += '<p class="text-muted">Inventory is empty.</p>';
                }

                // Render Goals Panel
                const renderGoal = (goalKey, depth = 0) => {
                    const goal = this.goals[goalKey];
                    if (!goal) return '';

                    let goalHtml = '';
                    if (goal.status === 'locked') {
                        if (this.areGoalConditionsMet(goal)) {
                            goalHtml = `<div class="mb-2" style="margin-left: ${depth * 20}px;">
                                <p class="mb-1"><strong>${goal.title}</strong> (Available)</p>
                                <small>${goal.description}</small>
                                <br><button class="btn btn-sm btn-primary mt-1" onclick="game.activateGoal('${goalKey}')">Start Quest</button>
                            </div>`;
                        } else {
                            const requirementsText = this.getGoalRequirementText(goal);
                            goalHtml = `<div class="mb-2" style="margin-left: ${depth * 20}px; opacity: 0.7;">
                                <p class="mb-1"><strong>${goal.title}</strong> (Locked)</p>
                                <small>${goal.description}</small>
                                <small class="d-block text-warning mt-1">${requirementsText}</small>
                            </div>`;
                        }
                    } else { // Active, completed, failed
                        goalHtml = `<div class="mb-2" style="margin-left: ${depth * 20}px;">
                            <p class="mb-1"><strong>${goal.title}</strong> (${goal.status})</p>
                            <small>${goal.description}</small>`;
                        if (goal.status === 'active') {
                            const subgoalsCompleted = !goal.subgoals || goal.subgoals.every(sgKey => this.goals[sgKey]?.status === 'completed');
                            if(subgoalsCompleted) {
                                goalHtml += `<br><button class="btn btn-sm btn-success mt-1" onclick="game.completeGoal('${goalKey}')">Complete</button>`;
                            }
                        }
                        goalHtml += `</div>`;
                    }

                    if (goal.status !== 'locked' && goal.subgoals && goal.subgoals.length > 0) {
                        goal.subgoals.forEach(subgoalKey => {
                            goalHtml += renderGoal(subgoalKey, depth + 1);
                        });
                    }
                    return goalHtml;
                }

                const allSubgoalKeys = new Set();
                Object.values(this.goals).forEach(g => {
                    if (g.subgoals) {
                        g.subgoals.forEach(sgKey => allSubgoalKeys.add(sgKey));
                    }
                });

                Object.keys(this.goals)
                    .filter(key => !allSubgoalKeys.has(key)) // Only render top-level goals
                    .forEach(key => this.ui.goalsPanel.innerHTML += renderGoal(key));


                // Render Map (disabled)
                this.renderMap();
            }

            saveState() {
                const state = {
                    currentLocation: this.currentLocation.name,
                    visitedLocations: Array.from(this.visitedLocations),
                    gameTime: this.gameTime,
                    reputation: this.reputation,
                    flags: Array.from(this.flags),
                    player: {
                        inventory: this.player.inventory,
                        equipment: this.player.equipment,
                        attributes: this.player.attributes,
                        skills: this.player.skills,
                    },
                    goals: Object.keys(this.goals).reduce((acc, key) => {
                        acc[key] = { status: this.goals[key].status };
                        return acc;
                    }, {})
                };
                localStorage.setItem('adventureGameSave', JSON.stringify(state));
                console.log("Game state saved.");
            }

            loadState() {
                const savedState = localStorage.getItem('adventureGameSave');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (this.locations[state.currentLocation]) {
                        this.currentLocation = this.locations[state.currentLocation];
                        this.visitedLocations = new Set(state.visitedLocations);
                        this.gameTime = state.gameTime;
                        this.reputation = state.reputation;
                        this.flags = new Set(state.flags);
                        this.player.inventory = state.player.inventory;
                        this.player.equipment = state.player.equipment;
                        this.player.attributes = state.player.attributes;
                        this.player.skills = state.player.skills;
                        for(const key in state.goals) {
                            if(this.goals[key]) this.goals[key].status = state.goals[key].status;
                        }
                        console.log("Game state loaded.");
                        this.logMessage("Welcome back! Your progress has been restored.", "game-event");
                        return true;
                    }
                }
                return false;
            }

            moveTo(locationName) {
                if (this.locations[locationName]) {
                    this.currentLocation = this.locations[locationName];
                    this.visitedLocations.add(locationName);
                    this.gameTime++; // Advance time by 1 day per travel
                    this.changeReputation('Danes', -1); // Reputation decay
                    this.logMessage(`You travel to <strong>${this.currentLocation.name}</strong>. It is now Day ${this.gameTime}.`, 'location');
                    this.logMessage(this.currentLocation.description);
                    this.updateUI();
                    this.saveState();
                } else {
                    console.error(`Attempted to move to unknown location: ${locationName}`);
                    this.logMessage(`Error: Could not find location "${locationName}".`, 'error');
                }
            }

            activateGoal(goalKey) {
                const goal = this.goals[goalKey];
                if (!goal) return;

                // If goal was locked, activate it and log a message.
                if (goal.status === 'locked') {
                    goal.status = 'active';
                    this.logMessage(`New goal: ${goal.title}`, 'goal');

                    // Activate any locked subgoals.
                    if (goal.subgoals && goal.subgoals.length > 0) {
                        goal.subgoals.forEach(subgoalKey => {
                            const subgoal = this.goals[subgoalKey];
                            if (subgoal && subgoal.status === 'locked') {
                                this.activateGoal(subgoalKey) // Recursive activation for sub-goals
                            }
                        });
                    }
                    this.updateUI();
                    this.saveState();
                }
            }

            addGoal(goalKey) {
                const goal = this.goals[goalKey];
                if (goal && goal.status === 'locked') {
                    this.activateGoal(goalKey);
                    this.updateUI();
                    this.saveState();
                }
            }

            completeGoal(goalKey) {
                const goal = this.goals[goalKey];
                if (goal && goal.status === 'active') {
                    // Check if all subgoals are completed
                    const subgoalsCompleted = goal.subgoals.every(sgKey => this.goals[sgKey].status === 'completed');
                    if (!subgoalsCompleted) {
                        this.logMessage(`You must complete the sub-tasks for "${goal.title}" first.`, 'warning');
                        return;
                    }

                    goal.status = 'completed';
                    this.flags.add(goalKey);
                    this.logMessage(`Goal completed: ${goal.title}`, 'goal');

                    // Grant rewards
                    if (goal.rewards) {
                        if (goal.rewards.items) {
                            goal.rewards.items.forEach(itemKey => {
                                this.player.inventory.push(itemKey);
                                this.logMessage(`You received the ${this.items[itemKey].name}.`, 'inventory');
                            });
                        }
                        if (goal.rewards.reputation) {
                            for (const faction in goal.rewards.reputation) {
                                this.changeReputation(faction, goal.rewards.reputation[faction]);
                            }
                        }
                    }

                    // Unlock next goals
                    goal.unlocks.forEach(unlockKey => this.addGoal(unlockKey));

                    this.updateUI();
                    this.saveState();
                }
            }

            async startGame(data) {
                // Load items
                for (const key in data.items) {
                    const itemData = data.items[key];
                    this.items[key] = new Item(itemData.name, itemData.description, itemData.type, itemData.slot, itemData.effects);
                }

                // Load characters
                for (const key in data.characters) {
                    const charData = data.characters[key];
                    this.characters[key] = new Character(charData.name, charData.attributes, charData.faction, charData.inventory, charData.skills, charData.equipment, charData.dialogue, charData.interactions);
                }

                // Load locations
                for (const key in data.locations) {
                    const locData = data.locations[key];
                    this.locations[key] = new Location(locData.name, locData.description, locData.connections, locData.characters, locData.items);
                }

                // Load goals
                for (const key in data.goals) {
                    const goalData = data.goals[key];
                    this.goals[key] = new Goal(goalData.title, goalData.description, goalData.type, goalData.status, goalData.subgoals, goalData.unlocks, goalData.conditions);
                }

                this.player = this.characters[data.playerCharacter];
                this.reputation = data.initialReputation;

                const loaded = this.loadState();
                if (!loaded) {
                    this.currentLocation = this.locations[data.startingLocation];
                    this.visitedLocations.add(this.currentLocation.name);
                    this.logMessage(`Welcome to ${data.gameTitle}!`, 'game-event');
                    this.logMessage(`You are at <strong>${this.currentLocation.name}</strong>.`);
                    // Activate initial goals
                    Object.keys(this.goals).forEach(key => {
                        if (this.goals[key].status === 'active') {
                            this.activateGoal(key);
                        }
                    });
                }

                this.logMessage(this.currentLocation.description);
                this.updateUI();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.game = new Game();
            game.startGame(gameData);
        });
    </script>
</body>
</html>
